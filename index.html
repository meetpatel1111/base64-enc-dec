<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cyberpunk Encoder/Decoder</title>
<style>
    :root {
        --bg-dark: #0d0d0d;
        --glass-bg: rgba(255, 255, 255, 0.05);
        --neon: #00ffcc;
        --neon-pink: #ff00ff;
    }
    body {
        font-family: 'Segoe UI', sans-serif;
        background: var(--bg-dark);
        color: white;
        margin: 0;
        padding: 20px;
        animation: fadeIn 1s ease-in-out;
    }
    h1 {
        text-align: center;
        text-shadow: 0 0 15px var(--neon);
        animation: glowPulse 2s infinite alternate;
    }
    @keyframes glowPulse {
        0% { text-shadow: 0 0 10px var(--neon); }
        100% { text-shadow: 0 0 30px var(--neon-pink); }
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .glass-card {
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 20px;
        margin: 15px auto;
        max-width: 900px;
        box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
    }
    textarea {
        width: 100%;
        height: 150px;
        background: transparent;
        border: none;
        color: var(--neon);
        font-size: 16px;
        padding: 10px;
        border-radius: 8px;
        outline: none;
        resize: vertical;
    }
    select, button {
        margin: 5px;
        padding: 10px 20px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: 0.3s;
    }
    select {
        background: #1e1e1e;
        color: var(--neon);
        box-shadow: 0 0 10px var(--neon);
    }
    button {
        background: var(--neon);
        color: black;
        box-shadow: 0 0 10px var(--neon);
    }
    button:hover {
        background: var(--neon-pink);
        box-shadow: 0 0 20px var(--neon-pink);
        transform: scale(1.05);
    }
    #history {
        max-height: 200px;
        overflow-y: auto;
        font-size: 14px;
    }
    .history-item {
        background: rgba(255,255,255,0.05);
        margin: 5px 0;
        padding: 5px;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.3s;
    }
    .history-item:hover {
        background: rgba(0,255,204,0.2);
    }
    progress {
        width: 100%;
        height: 8px;
        margin-top: 5px;
    }
    img.preview {
        max-width: 100%;
        margin-top: 10px;
        border-radius: 8px;
        box-shadow: 0 0 15px var(--neon);
    }
</style>
</head>
<body>

<h1>üîê Cyberpunk Encoder/Decoder</h1>

<div class="glass-card">
    <label>Encoding Type:</label>
    <select id="encodingType">
        <option value="base64">Base64 (Standard)</option>
        <option value="base64url">Base64 (URL-Safe)</option>
        <option value="hex">Hexadecimal</option>
        <option value="binary">Binary</option>
    </select>
    <textarea id="inputText" placeholder="Enter text or encoded data..."></textarea>
    <div>
        <button onclick="process('encode')">Encode</button>
        <button onclick="process('decode')">Decode</button>
        <button onclick="autoMode()">Auto</button>
        <button onclick="copyOutput()">Copy Output</button>
        <button onclick="downloadOutput()">Download Output</button>
        <button onclick="clearHistory()">Clear History</button>
    </div>
    <progress id="progressBar" value="0" max="100" style="display:none;"></progress>
</div>

<div class="glass-card">
    <textarea id="outputText" placeholder="Output will appear here..."></textarea>
    <div id="previewContainer"></div>
</div>

<div class="glass-card">
    <h3>üìú Conversion History</h3>
    <div id="history"></div>
</div>

<div class="glass-card" id="fileDrop" ondrop="dropHandler(event)" ondragover="dragOverHandler(event)">
    üìÇ Drag & drop a file here, or <input type="file" id="fileInput" onchange="handleFile(this)">
</div>

<script>
    const inputText = document.getElementById("inputText");
    const outputText = document.getElementById("outputText");
    const historyDiv = document.getElementById("history");
    const progressBar = document.getElementById("progressBar");
    const previewContainer = document.getElementById("previewContainer");

    let historyData = JSON.parse(localStorage.getItem("historyData") || "[]");

    function saveHistory(input, output, mode) {
        const item = { input, output, mode, time: new Date().toLocaleTimeString() };
        historyData.unshift(item);
        if (historyData.length > 20) historyData.pop();
        localStorage.setItem("historyData", JSON.stringify(historyData));
        renderHistory();
    }

    function renderHistory() {
        historyDiv.innerHTML = "";
        historyData.forEach((item, index) => {
            const div = document.createElement("div");
            div.className = "history-item";
            div.textContent = `[${item.time}] ${item.mode.toUpperCase()} - ${item.output.substring(0,50)}...`;
            div.onclick = () => {
                inputText.value = item.input;
                outputText.value = item.output;
            };
            historyDiv.appendChild(div);
        });
    }

    function showProgress() {
        progressBar.style.display = "block";
        progressBar.value = 0;
        let progress = 0;
        const interval = setInterval(() => {
            progress += 5;
            progressBar.value = progress;
            if (progress >= 100) clearInterval(interval);
        }, 30);
    }

    function encode(type, text) {
        if (type === "base64") return btoa(unescape(encodeURIComponent(text)));
        if (type === "base64url") return btoa(unescape(encodeURIComponent(text))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        if (type === "hex") return Array.from(text).map(c => c.charCodeAt(0).toString(16).padStart(2,'0')).join('');
        if (type === "binary") return Array.from(text).map(c => c.charCodeAt(0).toString(2).padStart(8,'0')).join(' ');
    }

    function decode(type, text) {
        if (type === "base64") return decodeURIComponent(escape(atob(text)));
        if (type === "base64url") return decodeURIComponent(escape(atob(text.replace(/-/g, '+').replace(/_/g, '/'))));
        if (type === "hex") return text.match(/.{1,2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join('');
        if (type === "binary") return text.split(' ').map(bin => String.fromCharCode(parseInt(bin, 2))).join('');
    }

    function process(mode) {
        showProgress();
        const type = document.getElementById("encodingType").value;
        try {
            let result = (mode === "encode") ? encode(type, inputText.value) : decode(type, inputText.value);
            outputText.value = "";
            let i = 0;
            function typeEffect() {
                if (i < result.length) {
                    outputText.value += result[i++];
                    setTimeout(typeEffect, 2);
                }
            }
            typeEffect();
            saveHistory(inputText.value, result, mode);
            if (result.startsWith("data:image")) {
                let img = document.createElement("img");
                img.src = result;
                img.className = "preview";
                previewContainer.innerHTML = "";
                previewContainer.appendChild(img);
            } else {
                previewContainer.innerHTML = "";
            }
        } catch {
            alert("Invalid input for selected encoding type!");
        }
    }

    function autoMode() {
        if (/^[A-Za-z0-9+/=]+$/.test(inputText.value.trim())) {
            process('decode');
        } else {
            process('encode');
        }
    }

    function copyOutput() {
        outputText.select();
        document.execCommand("copy");
        alert("Copied to clipboard!");
    }

    function downloadOutput() {
        const blob = new Blob([outputText.value], { type: "text/plain" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "output.txt";
        a.click();
    }

    function handleFile(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = () => inputText.value = reader.result;
            reader.readAsDataURL(file);
        }
    }

    function dropHandler(ev) {
        ev.preventDefault();
        if (ev.dataTransfer.items) {
            for (let item of ev.dataTransfer.items) {
                if (item.kind === 'file') {
                    handleFile({ files: [item.getAsFile()] });
                }
            }
        }
    }
    function dragOverHandler(ev) {
        ev.preventDefault();
    }

    function clearHistory() {
        historyData = [];
        localStorage.removeItem("historyData");
        renderHistory();
    }

    renderHistory();
</script>
</body>
</html>
